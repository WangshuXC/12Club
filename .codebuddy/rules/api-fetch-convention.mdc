---
description: 
alwaysApply: true
enabled: true
updatedAt: 2026-02-05T06:21:58.256Z
provider: 
---

# API 请求与路由规范

本规范定义了项目中 HTTP 请求和 API 路由的标准实现方式。

## 一、客户端请求规范

### 1.1 必须使用封装的 Fetch 方法

所有客户端 HTTP 请求**必须**使用 `@/utils/fetch.ts` 中封装的方法，**禁止**直接使用原生 `fetch`。

**可用方法**：

```typescript
import { FetchGet, FetchPost, FetchPut, FetchDelete, FetchFormData } from '@/utils/fetch'

// GET 请求
const data = await FetchGet<ResponseType>('/admin/resource', { page: 1, limit: 10 })

// POST 请求
const result = await FetchPost<ResponseType>('/admin/resource', { name: 'xxx', ... })

// PUT 请求
const updated = await FetchPut<ResponseType>('/admin/resource', { id: 1, name: 'xxx', ... })

// DELETE 请求
const deleted = await FetchDelete<ResponseType>('/admin/resource', { id: 1 })

// FormData 请求（用于文件上传）
const formData = new FormData()
formData.append('file', file)
const uploaded = await FetchFormData<ResponseType>('/upload', formData)
```

### 1.2 禁止的做法

```typescript
// ❌ 错误：直接使用 fetch
const res = await fetch('/api/admin/resource')

// ❌ 错误：使用 axios 或其他库
import axios from 'axios'
const res = await axios.get('/api/admin/resource')
```

---

## 二、API 路由规范

### 2.1 请求解析必须使用 parseQuery

所有 API 路由**必须**使用 `@/utils/parseQuery.ts` 中的方法解析请求参数，配合 Zod Schema 进行类型验证。

**可用方法**：

```typescript
import { ParseGetQuery, ParsePostBody, ParsePutBody, ParseDeleteQuery, ParseFormData } from '@/utils/parseQuery'

// GET 请求解析
export async function GET(req: NextRequest) {
  const input = ParseGetQuery(req, yourSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }
  // input 已经是类型安全的
}

// POST 请求解析
export async function POST(req: NextRequest) {
  const input = await ParsePostBody(req, yourSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }
}

// PUT 请求解析
export async function PUT(req: NextRequest) {
  const input = await ParsePutBody(req, yourSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }
}

// DELETE 请求解析
export async function DELETE(req: NextRequest) {
  const input = ParseDeleteQuery(req, yourSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }
}

// FormData 解析
export async function POST(req: NextRequest) {
  const input = await ParseFormData(req, yourSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }
}
```

### 2.2 API 文件结构规范

API 路由**必须**将不同的 HTTP 方法抽离成单独的文件，`route.ts` 作为入口文件统一调用。

**标准目录结构**：

```
src/app/api/[domain]/[resource]/
├── route.ts        # 入口文件，处理 HTTP 方法路由
├── get.ts          # GET 方法的业务逻辑
├── create.ts       # POST 方法的业务逻辑（或命名为 post.ts）
├── update.ts       # PUT 方法的业务逻辑
├── delete.ts       # DELETE 方法的业务逻辑
└── [子功能]/        # 如有子功能，创建子目录
    ├── route.ts
    └── ...
```

### 2.3 route.ts 入口文件模板

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { ParseGetQuery, ParsePostBody, ParsePutBody, ParseDeleteQuery } from '@/utils/parseQuery'
import {
  getResourceSchema,
  createResourceSchema,
  updateResourceSchema,
  deleteResourceSchema
} from '@/validations/xxx'
import { verifyHeaderCookie } from '@/utils/actions/verifyHeaderCookie'
import { getResource } from './get'
import { createResource } from './create'
import { updateResource } from './update'
import { deleteResource } from './delete'

export async function GET(req: NextRequest) {
  // 1. 解析并验证请求参数
  const input = ParseGetQuery(req, getResourceSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }

  // 2. 验证用户身份（如需要）
  const payload = await verifyHeaderCookie()
  if (!payload) {
    return NextResponse.json('用户未登录')
  }

  // 3. 调用业务逻辑
  const res = await getResource(input)
  return NextResponse.json(res)
}

export async function POST(req: NextRequest) {
  const input = await ParsePostBody(req, createResourceSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }

  const payload = await verifyHeaderCookie()
  if (!payload) {
    return NextResponse.json('用户未登录')
  }

  const res = await createResource(input)
  return NextResponse.json(res)
}

export async function PUT(req: NextRequest) {
  const input = await ParsePutBody(req, updateResourceSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }

  const payload = await verifyHeaderCookie()
  if (!payload) {
    return NextResponse.json('用户未登录')
  }

  const res = await updateResource(input)
  return NextResponse.json(res)
}

export async function DELETE(req: NextRequest) {
  const input = ParseDeleteQuery(req, deleteResourceSchema)
  if (typeof input === 'string') {
    return NextResponse.json(input)
  }

  const payload = await verifyHeaderCookie()
  if (!payload) {
    return NextResponse.json('用户未登录')
  }

  const res = await deleteResource(input)
  return NextResponse.json(res)
}
```

### 2.4 业务逻辑文件模板

```typescript
// get.ts 示例
import { z } from 'zod'
import { prisma } from '@/../prisma'
import { getResourceSchema } from '@/validations/xxx'

export const getResource = async (
  input: z.infer<typeof getResourceSchema>
) => {
  try {
    // 业务逻辑实现
    const data = await prisma.resource.findMany({
      // ...
    })
    
    return { success: true, data }
  } catch (error) {
    console.error('获取资源失败:', error)
    return error instanceof Error ? error.message : '获取资源时发生未知错误'
  }
}
```

---

## 三、类型定义规范

### 3.1 类型文件位置

类型定义**必须**按用途分类放置，**禁止**在组件或 API 文件中直接定义复杂类型。

| 类型用途 | 存放位置 | 文件格式 |
|---------|---------|---------|
| API 请求/响应类型 | `@/types/api/` | `*.d.ts` |
| 客户端组件类型 | `@/types/common/` | `*.d.ts` |

### 3.2 API 类型定义 (`@/types/api/`)

API 相关的类型定义**必须**放在 `@/types/api/` 目录下，按功能模块分类。

**目录结构**：
```
src/types/api/
├── admin.d.ts         # 管理员相关 API 类型
├── user.d.ts          # 用户相关 API 类型
├── resource.d.ts      # 资源相关 API 类型
├── comment.d.ts       # 评论相关 API 类型
├── message.d.ts       # 消息相关 API 类型
├── search.d.ts        # 搜索相关 API 类型
└── admin/             # 管理员模块子类型（如需要）
    └── xxx.d.ts
```

**示例**：

```typescript
// @/types/api/admin.d.ts
import type { ResourceComment } from './comment'
import type { Message } from './message'

// API 响应数据类型
export interface AdminResource {
  id: number
  dbId: string
  name: string
  banner: string
  created: Date | string
  author: string
  user: {
    id: number
    name: string
    avatar: string
  }
  // ...
}

// API 响应结构类型
export interface AdminResourceListResponse {
  resources: AdminResource[]
  total: number
}

export interface AdminResourceDetailResponse {
  resource: AdminResource
}
```

### 3.3 客户端组件类型 (`@/types/common/`)

客户端组件使用的类型**必须**放在 `@/types/common/` 目录下。

**目录结构**：
```
src/types/common/
├── index.d.ts              # 全局类型扩展（如 Window）
├── home.d.ts               # 首页相关组件类型
├── page.d.ts               # 页面通用类型
└── detail-container.d.ts   # 详情页容器类型
```

**示例**：

```typescript
// @/types/common/home.d.ts
export interface HomeCarousel {
  title: string
  href: string
  imageSrc: string
}

export interface HomeComments {
  id: number
  content: string
  created: string
  user?: User
  resource?: Resource
}
```

```typescript
// @/types/common/page.d.ts
export interface QueryParams {
  category: string
  page?: number
  sortOrder: SortOrder
  sortField: SortField
  type: string
  language: string
  status: string
}
```

### 3.4 类型导入规范

```typescript
// ✅ 正确：从 types 目录导入
import type { AdminResource } from '@/types/api/admin'
import type { HomeCarousel } from '@/types/common/home'

// ❌ 错误：在组件中定义复杂类型
interface AdminResource {
  // 不要这样做
}
```

---

## 四、Zod Schema 验证规范

### 4.1 Schema 文件位置

所有 API 请求参数验证 Schema **必须**放在 `@/validations/` 目录下，按功能模块分类。

**目录结构**：
```
src/validations/
├── admin.ts      # 管理员 API 验证
├── auth.ts       # 认证相关验证
├── user.ts       # 用户相关验证
├── resource.ts   # 资源相关验证
├── comment.ts    # 评论相关验证
├── search.ts     # 搜索相关验证
├── edit.ts       # 编辑相关验证
├── page.ts       # 分页通用验证
├── patch.ts      # 补丁相关验证
└── series.ts     # 系列相关验证
```

### 4.2 Schema 命名规范

Schema 命名**必须**遵循以下格式：`[模块名][操作][目标]Schema`

```typescript
// 示例命名
adminGetResourceSchema      // 管理员获取资源
adminCreateResourceSchema   // 管理员创建资源
adminUpdateResourceSchema   // 管理员更新资源
adminDeleteResourceSchema   // 管理员删除资源
userGetProfileSchema        // 用户获取个人信息
```

### 4.3 常用验证模式

```typescript
// @/validations/admin.ts
import { z } from 'zod'

// 分页查询 Schema
export const adminPaginationSchema = z.object({
  page: z.coerce.number().min(1).max(9999999),
  limit: z.coerce.number().min(1).max(100),
  search: z.string().max(300, { message: '搜索内容最多 300 个字符' }).optional(),
  sortField: z.enum(['created', 'updated', 'name']).default('updated'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
})

// 获取资源 Schema（继承分页）
export const adminGetResourceSchema = z.object({
  page: z.coerce.number().min(1).max(9999999),
  limit: z.coerce.number().min(1).max(100),
  search: z.string().max(300).optional(),
  types: z.string().optional().transform((val) => {
    if (!val) return undefined
    return val.split(',').filter(type => ['a', 'c', 'g', 'n'].includes(type)) as ('a' | 'c' | 'g' | 'n')[]
  }),
  sortField: z.enum(['created', 'view', 'download', 'favorite_by', 'comment', 'updated', 'released']).default('updated'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
})

// 创建资源 Schema
export const adminCreateResourceSchema = z.object({
  name: z.string().trim().min(1, { message: '资源名称不能为空' }),
  dbId: z.string().trim().min(1, { message: '资源DBID不能为空' }),
  introduction: z.string().trim().min(1, { message: '资源介绍不能为空' }),
  // ...
})

// 更新资源 Schema
export const adminUpdateResourceSchema = z.object({
  id: z.coerce.number().min(1).max(9999999),
  name: z.string().trim().min(1, { message: '资源名称不能为空' }),
  dbId: z.string().trim().min(1, { message: '资源DBID不能为空' }),
  // ...
})

// 删除资源 Schema
export const adminDeleteResourceSchema = z.object({
  id: z.coerce.number().min(1).max(9999999)
})
```

### 4.4 常用 Zod 验证方法

```typescript
import { z } from 'zod'

// 字符串验证
z.string()
  .trim()                                    // 去除首尾空格
  .min(1, { message: '不能为空' })           // 最小长度
  .max(100, { message: '不能超过100字符' })  // 最大长度

// 数字验证（从字符串转换）
z.coerce.number()                            // 自动转换为数字
  .min(1)                                    // 最小值
  .max(9999999)                              // 最大值

// 枚举验证
z.enum(['asc', 'desc'])                      // 枚举值
  .default('desc')                           // 默认值

// 可选字段
z.string().optional()                        // 可选
z.string().nullable()                        // 可为 null

// 数组验证
z.array(z.string())
  .min(1, { message: '至少需要一项' })
  .max(100, { message: '最多100项' })

// 转换
z.string().transform((val) => val.split(','))  // 字符串转数组

// 条件验证
z.object({
  type: z.enum(['a', 'b']),
  data: z.string()
}).refine(
  (data) => data.type === 'a' ? data.data.length > 0 : true,
  { message: '类型为 a 时 data 不能为空' }
)
```

### 4.5 Schema 与类型联动

```typescript
// 在业务逻辑文件中使用
import { z } from 'zod'
import { adminGetResourceSchema } from '@/validations/admin'

// 从 Schema 推断类型
type GetResourceInput = z.infer<typeof adminGetResourceSchema>

export const getResource = async (
  input: z.infer<typeof adminGetResourceSchema>
) => {
  const { page, limit, search, sortField, sortOrder } = input
  // 业务逻辑...
}
```

---

## 五、快速参考

### 5.1 请求方法对照表

| 场景 | 客户端方法 | 服务端解析方法 |
|------|-----------|---------------|
| 查询数据 | `FetchGet` | `ParseGetQuery` |
| 创建数据 | `FetchPost` | `ParsePostBody` |
| 更新数据 | `FetchPut` | `ParsePutBody` |
| 删除数据 | `FetchDelete` | `ParseDeleteQuery` |
| 上传文件 | `FetchFormData` | `ParseFormData` |

### 5.2 文件位置速查表

| 内容类型 | 存放位置 |
|---------|---------|
| API 路由入口 | `src/app/api/[domain]/[resource]/route.ts` |
| API 业务逻辑 | `src/app/api/[domain]/[resource]/get.ts` 等 |
| API 类型定义 | `src/types/api/*.d.ts` |
| 组件类型定义 | `src/types/common/*.d.ts` |
| 请求验证 Schema | `src/validations/*.ts` |

### 5.3 创建新 API 的检查清单

- [ ] 在 `@/validations/` 添加对应的 Zod Schema
- [ ] 在 `@/types/api/` 添加响应类型定义
- [ ] 创建 `route.ts` 入口文件
- [ ] 将 GET/POST/PUT/DELETE 方法抽离为独立文件
- [ ] 使用 `ParseXXX` 方法解析请求
- [ ] 客户端使用 `FetchXXX` 方法调用